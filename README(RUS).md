#### Установка:
1. клонировать (скачать) этот репозиторий
1. установить менеджер пакетов [Anaconda]. [инструкция по установке на windows]
1. [создать виртуальную среду] из файла conda_env.yml
1. [установить inkscape]
1. желательно установить [PyCharm] (для редактирования кода), [настроить PyCharm для работы со средой Anaconda]

[Anaconda]: https://www.anaconda.com/products/individual
[инструкция по установке на windows]: https://docs.anaconda.com/anaconda/install/windows/
[создать виртуальную среду]: https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#creating-an-environment-from-an-environment-yml-file
[PyCharm]: https://www.jetbrains.com/pycharm/download/
[настроить PyCharm для работы со средой Anaconda]: https://www.jetbrains.com/help/pycharm/conda-support-creating-conda-virtual-environment.html
[установить inkscape]: https://inkscape.org/

---

#### Использование:
1. Предполагается, что сложные функции хранятся в папке lib или других папках, являющихся [пакетами python]
1. Эти сложные функции вызываются простыми функциями из cкриптов на python, лежащих в папках `scripts` и аналогичных,
не являющихся пакетами python.
1. Скрипты не содержат сложных конструкций, их можно удалять и быстро писать новые. 
    > для быстрых изменений хорошо подходят легковесные редакторы: notepad++, sublime text, atom.
    также мб удобным использовать консоли ipython, jupyter, которые способны сохранять сессии в виде json-файлов с расширением `.ipynb`
1. Папка `scripts` содержит рабочие примеры скриптов.
    > При использовании git желательно создать новую папку типа `ignore_scripts` или `local_scripts`.
    Префиксы `local_` и `ignore_` прописаны в файлe `.gitignore`.
1. Скрипты активируются через командную оболочку системы сконфигурированную Anaconda.
(на windows в меню start после инсталляции есть опция Anaconda prompt, 
на linux Anaconda конфигурирует bash автоматически при запуске)
1. После запуска оболочки необходимо активировать среду командой `conda activate brainS`.
1. Скрипт активируется командой типа `python "c:/users/user/desktop/MiceBrainMriSegmentation/scripts/example_script.py"`
    > Писать скрипты, которые принимают аргументы командной строки -- так себе идея 
    (несмотря на то, что в python есть удобный модуль argparse). 
    > Проще менять скрипт каждый раз или завести несколько копий.
[пакетами python]: https://www.learnpython.org/en/Modules_and_Packages (about python modules and packages)

#### Стандартный способ работы с проектом:
1. Запустить скрипт `scripts/new_project.py` вышеописанным способом.
1. Переместить в папку img_raw изображения `.img`, относящиеся к проекту, переименовав их установленным образом.
    > По умолчанию считается, что файлы имеют имена `{группа}_{час}_{№ животного}_{срез}` (без расширения).
    > Эта конвенция прописана в `lib/default_config.yml` под ключом `global/file_naming_convention`.                                                                                                                >
1. Для разметки изображений при помощи imagej необходимо создать список файлов при помощи `scripts/list_raw_images.py`.
Работа со скриптом imagej:
    1. Открыть в качестве скрипта imagej файл `scripts/brain_segmentation_with_imagej.txt`.
    1. Нажать `P` (макрос `select working directory`). Выбрать любой файл в корневой папке проекта.
    1. Нажать `I` (макрос `initiate sequence`).
    1. Выбрать референсную область, нажать `C` (`capture background`).
    1. Провести линию по направлению, в к-ром на изображении вертикаль, нажать `R` (`capture rotation`).
    1. Выделить левую/правую половину мозга, нажать `Q`/`W` (`capture left hemisphere`/`capture right hemisphere`).
    1. Повторить для другой половины мозга.
    1. Нажать `G` (`next in sequence`, аналогичен `initiate sequence`, но инкрементирует счетчик в `pointer.txt`).
    1. Повторить разметку. 
    >Процесс разметки можно прервать в любой момент: файл `{проект}/ij_img_list.txt` 
    сохраняет список изображений, а файл `{проект}/ij_pointer.txt` -- текущее изображение для разметки.
    >Чтобы продолжить разметку с последнего изображения, нужно запустить макрос `I`.
1. Запустить `scripts/images_to_npy.py`
1. Запустить `scripts/compose_metadata_crop_images.py`
1. Если папка с масками еще не создана, нужно [создать](#Стандартный-способ-создания-папки-с-масками:).
1. Запустить `scripts/segmentation.py`
1. Запустить `plot_segmentation_summary.py`, если нужно
#### Стандартный способ создания папки с масками:
1. Запустить скрипт `scripts/new_masks_folder.py`.
1. Скрипт создает файл `{masks_folder}/download_info.yml`. Этот файл требует ручного редактирования.
он является "скрытым аргументом" для функций, название к-рых начинается с `download_`
и принимающих `masks_folder` в качестве явного аргумента.
    > Файл `download_info.yml` по умолчанию корректно заполнен. Это значит, что остальные функции
    скрипта скачают небольшое кол-во данных из интернета. Это может занять 15-30 сек.
    Можно закомментировать строки с вызовами функций с префиксом `download_` при запуске скрипта, чтобы
    чтобы избежать ненужных загрузок.
1. Отредактировать `download_info.yml`. Названия срезов атласа должны совпадать с названиями срезов в именах изображений.
    > Скорее всего придется редактировать только ключ `svg_names_and_ids`. 
    вложенные в него ключи будут служить именами svg-файлов, а их значения -- номерами срезов.
    В установлении id срезов может помочь таблица `{masks_folder}/slice_id_table.txt`, создаваемая
    функцией `project_ops.download_slice_ids()`.
1. Закомментировать в `scripts/new_masks_folder.py` строку
с вызовом функции `project_ops.new_masks_folder()` (выдает ошибку, если папка уже существует).
Повторно запустить скрипт.
1. В `.svg` файл необходимо добавить прямоугольник, прямоугольнику добавить xml-аттрибут `structure_id`,
со значением `bbox`. По верхней, нижней, правой и левой границам этого
прямоугольника будут определяться границы `.png` изображения, которые скрипты получают с этого файла
    > В `.svg` файлы срезов можно добавлять различные объекты (растровые изображения, линии).
    Скрипты сконструированы так, что все видимые объекты без xml-аттрибута `structure_id` 
    не повлияют на внешний вид при рендере.
    xml-тэги svg-объектов, которые обязательны в svg-файле inkscape или не имеют визуального отображения сами по себе
    (группы, холст, метаданные и тп.) прописаны в конфигурационном файле.
1. В файле конфигурации `lib/default_config.yml` указать путь к inkscape (ключ `ontology/inkscape_exe`).
    > чтобы убедиться, что ключ указан правильно, можно открыть коммандную строку и попробовать вызвать
    inkscape: если указанный путь `'c:/users/user/my precious/inkscape'` команда будет 
    `"c:/users/user/my precious/inkscape" --help` (и bash и оболочка windows не любят `'` по каким-то причинам).
1. Запустить скрипт `scripts/prerender_masks.py`. маски готовы к использованию.
---

#### Основные идеи:
###### Файловая система:
* Данные, обрабатываемые вместе, хранятся внутри одной папки (project_folder),
каждый вид данных в собственной подпапке
* Программы могут изменять только эти целевые папки, желательно только 1-2 подпапки за раз
* Папки проектов, внутри к-рых хранятся похожие данные имеют одинаковую структуру.
* Имена имеют значение. Если не делать паттерн-мэтчинг по именам, нужно будет составлять
крайне длинные списки файлов для обработки и передавать их в функцию.
Поэтому: метаданные к изображению должны иметь то же имя, что и изображение
(изображение: `abracadabra.npy`, метаданные: `abracadabra.yml`),
то же самое касается масок и списков структур (онтологий) и вообще всего-всего.

###### Способ хранения данных:
* Массивы хранятся в виде изображений или файлов .npy, .npz, к-рые [читаются библиотекой numpy].
Не надо их хранить в виде двоичных строк, оставим это программистам с/с++.
* таблицы хранятся в виде csv файлов c разделителем `\t` (табуляция).
* файлы, предназначенные только для чтения с помощью python хранятся в виде
сериализованных объектов python, с расширениями .pickle, .pth (для pytorch).
* Конфигурация/древовидные структуры данных хранятся в [.yml] или .xml файлах.
* .yml файлы просто править в любом редакторе кода, они хорошо читаются человеком, лучше использовать их.
* Константы к модулям библиотеки хранятся в одном файле .yml, в виде словаря (хэш-таблицы).
Ключи внешнего уровня совпадают с именами .py файлов библиотеки + есть общий ключ 'global'.
После импорта модуля `filename.py` предполагается загружать конфигурацию модуля с помощью функции `lib.load_config()`.
Функция по умолчанию загружает данные из `lib/default_config.yml`.
Данные с ключом `filename` загружаются в переменную `filename._LOC`, с ключом `global` --
в переменную `filename._GLOB`.

[читаются библиотекой numpy]: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html
[.yml]: https://en.wikipedia.org/wiki/YAML

###### Общие советы для тех, кто решится добавлять новый функционал:
* Если какие-то данные могут обрабатываться отдельно, лучше обрабатывать их отдельно,
сохраняя промежуточный результат, например, дамп памяти.
    > В сочетании с жестко детерминированными именами файлов, это позволяет распараллелить
    долго выполняющиеся скрипты без использования инструкций блокировок.
    В простейшем случае, можно просто запустить 2 аналогичных скрипта
    с 2х разных терминалов, чтобы не разбираться с модулями python для параллельных вычислений.
* Паттерн-мэтчинг -- это круто, поэтому:
    * Названия файлов должны отражать их взаимные отношения.
    * Функции должны находить файлы в папках по названиям или частям названия.
    * Названия временных и промежуточных файлов дожны быть жестко детерминированы,
    чтобы в случае сбоев работы программы/компьютера можно было легко понять,где прервалось выполнение, и продолжить.
* Чем меньше ветвлений в потоке выполнения, тем проще дебажить, и тем меньше вероятность ошибок в рантайме.
* Хуже ошибок в рантайме -- запись рандомных данных. Необходимо исключать возможность смешивания старых и новых данных,
проверяя наличие старых данных при помощи инструкций типа assert и тп.
* Существует особая форма мазохизма, называемая изменяемыми объектами. Крайне желательно самому классы таких объектов не писать.
В python они уже написаны опытными людьми. Если нужно создать класс, лучше использовать [dataclass] с неизменяемыми объектами.
Неизменяемые объекты хороши тем, что результат операций с ними зависит только от параметров инициализации таких объектов.

[dataclass]: https://realpython.com/python-data-classes/