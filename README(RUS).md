#### Установка:
1. клонировать (скачать) этот репозиторий
2. установить менеджер пакетов [Anaconda]. [инструкция по установке на windows]
3. [создать виртуальную среду] из файла conda_env.yml
4. желательно установить [PyCharm] (для редактирования кода), [настроить PyCharm для работы со средой Anaconda]

[Anaconda]: https://www.anaconda.com/products/individual
[инструкция по установке на windows]: https://docs.anaconda.com/anaconda/install/windows/
[создать виртуальную среду]: https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#creating-an-environment-from-an-environment-yml-file
[PyCharm]: https://www.jetbrains.com/pycharm/download/
[настроить PyCharm для работы со средой Anaconda]: https://www.jetbrains.com/help/pycharm/conda-support-creating-conda-virtual-environment.html

#### Использование:
1. Предполагается, что для использования нужно написать короткий скрипт на python (рабочие примеры есть в папке scripts).
2. Скрипты активируются через командную оболочку системы сконфигурированную Anaconda.
(на windows в меню start после инсталляции есть опция Anaconda prompt, 
на linux Anaconda конфигурирует bash автоматически при запуске)
3. После запуска оболочки необходимо активировать среду командой `conda activate brainS`
4. Скрипт активируется командой типа `python "c:/users/user/desktop/MiceBrainMriSegmentation/scripts/example_script.py"`
* Писать скрипты, которые принимают аргументы командной строки -- так себе идея, проще менять скрипт каждый раз
или завести новый.

#### Стандартный способ работы с проектом:
1. открыть скрипт `scripts/new_project.py` в текстовом редакторе (для быстрых изменений хорошо подходят
легковесные редакторы: notepad++, sublime text, atom). Изменить в тексте скрипта путь к новому проекту.
Желательно сохранить скрипт в другой папке, имя которой начинается с `local_` 
(они прописаны в паттернах .gitignore этого репозитория), например, `local_scripts/new_project.py`. Запустить скрипт.
2. Переместить в папку img_raw изображения `.img`, относящиеся к проекту, переименовав их установленным образом.
по умолчанию считается, что файлы имеют имена `{группа}_{час}_{№ животного}_{срез}` (без расширения).
Эта конвенция прописана в `lib/default_config.yml` под ключом `global/file_naming_convention`
3. Для разметки изображений при помощи imagej необходимо создать список файлов при помощи `scripts/list_raw_images.py`.
скрипт запускается аналогично (1.).
Открыть imagej. открыть в качестве скрипта imagej файл `scripts/brain_segmentation_with_imagej.txt`.
Нажать `P` (макрос `select working directory`). Нажать `I` (макрос `initiate sequence`).
Выбрать референсную область, нажать `C` (`capture background`), провести линию по направлению,
в к-ром на изображении вертикаль, нажать `R` (`capture rotation`),
выделить левую/правую половину мозга, нажать `Q`/`W` (`capture right hemisphere`/`capture left hemisphere`).
Нажать `G` (`next in sequence`, аналогичен `initiate sequence`, но инкрементирует счетчик в `pointer.txt`).
Повторить разметку. разметку можно прервать в любой момент: файл `{проект}/ij_img_list.txt` сохраняет список
изображений, а файл `{проект}/ij_pointer.txt` -- текущее изображение для разметки.
Чтобы продолжить разметку с последнего изображения, нужно запустить макрос `I`.
4. Запустить cкрипт `scripts/images_to_npy.py`, затем `scripts/compose_metadata_crop_images.py`, аналогично (1.)
5. Если папка с масками еще не создана, нужно создать.
6. Запустить скрипт `scripts/segmentation.py`, затем `plot_segmentation_summary.py`

#### Основные идеи:
* Данные, обрабатываемые вместе, хранятся внутри одной папки (project_folder),
каждый вид данных в собственной подпапке
* Программы могут изменять только эти целевые папки, желательно только 1-2 подпапки за раз
* Папки проектов, внутри к-рых хранятся похожие данные имеют одинаковую структуру.
* Имена имеют значение. Если не делать паттерн-мэтчинг по именам, нужно будет составлять
крайне длинные списки файлов для обработки и передавать их в функцию.
Поэтому: метаданные к изображению должны иметь то же имя, что и изображение
(изображение: `abracadabra.npy`, метаданные: `abracadabra.yml`),
то же самое касается масок и списков структур (онтологий) и вообще всего-всего.
* Паттерн-мэтчинг -- это круто.
---
* Массивы хранятся в виде изображений или файлов .npy, .npz, к-рые [читаются библиотекой numpy].
Не надо их хранить в виде двоичных строк, оставим это программистам с/с++.
* таблицы хранятся в виде csv файлов c разделителем `\t` (табуляция).
* файлы, предназначенные только для чтения с помощью python хранятся в виде
сериализованных объектов python, с расширениями .pickle, .pth (для pytorch).
* Конфигурация/древовидные структуры данных хранятся в [.yml] или .xml файлах.
* .yml файлы просто править в любом редакторе кода, они хорошо читаются человеком, лучше использовать их.
* Константы к модулям библиотеки хранятся в одном файле .yml, в виде словаря (хэш-таблицы).
Ключи внешнего уровня совпадают с именами .py файлов библиотеки + есть общий ключ 'global'.
Данные с ключом `filename` загружаются в переменную `filename._LOC`, с ключом `global` --
в переменную `filename._GLOB`.

[читаются библиотекой numpy]: https://numpy.org/devdocs/reference/generated/numpy.lib.format.html
[.yml]: https://en.wikipedia.org/wiki/YAML

---
* Если какие-то данные могут обрабатываться отдельно, лучше обрабатывать их отдельно,
сохраняя промежуточный результат. Даже если промежуточный результат -- дамп памяти.
* Чем меньше ветвлений в потоке выполнения, тем проще дебажить, и тем меньше вероятность ошибок в рантайме.
* Хуже ошибок в рантайме -- запись рандомных данных. Необходимо исключать возможность смешивания старых и новых данных,
проверяя наличие старых данных при помощи инструкций типа assert и тп.
